// server.min.js - Minimal proof server for real-time trading
const express = require("express");
const http = require("http");
const cors = require("cors");
const { Server } = require("socket.io");

const PORT = process.env.PORT || 5001; // Different port to avoid conflicts
const app = express();

app.use(cors({ origin: true, credentials: false }));
app.get("/api/health", (_, res) => res.json({ ok: true, mode: "minimal" }));

const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: true, credentials: false },
  path: "/socket.io",
});

let demoInterval = null;
let perf = { pnl: 0, trades: 0, wins: 0, balance: 10000 };

const symbols = {
  EURUSD: 1.0850,
  GBPUSD: 1.2650,
  USDJPY: 148.5,
  AUDUSD: 0.6580,
  USDCAD: 1.3520,
  EURGBP: 0.8570,
  USDCHF: 0.8920,
  NZDUSD: 0.6120,
  EURJPY: 161.2,
  GBPJPY: 187.8,
  AUDJPY: 97.7,
  CADJPY: 109.8
};

function randomWalk(p) {
  const step = (Math.random() - 0.5) * 0.0015;
  return +(p * (1 + step)).toFixed(5);
}

function emitTicks() {
  Object.keys(symbols).forEach((s) => {
    const oldPrice = symbols[s];
    symbols[s] = randomWalk(symbols[s]);
    const change = +((symbols[s] - oldPrice) / oldPrice * 100).toFixed(4);
    
    io.emit("tick", { 
      symbol: s, 
      price: symbols[s], 
      ts: Date.now(),
      change: change
    });
  });
}

function fakeTrade() {
  // 55% win probability
  const win = Math.random() < 0.55;
  const pnl = +(win ? (7.5 + Math.random() * 5) : -(5.0 + Math.random() * 3)).toFixed(2);
  perf.trades += 1;
  if (win) perf.wins += 1;
  perf.pnl = +(perf.pnl + pnl).toFixed(2);
  perf.balance = +(10000 + perf.pnl).toFixed(2);
  const winRate = perf.trades ? Math.round((perf.wins / perf.trades) * 100) : 0;

  const trade = {
    id: `trade_${Date.now()}`,
    symbol: Object.keys(symbols)[Math.floor(Math.random() * Object.keys(symbols).length)],
    action: win ? 'BUY' : 'SELL',
    price: symbols[Object.keys(symbols)[Math.floor(Math.random() * Object.keys(symbols).length)]],
    volume: 0.1,
    pnl: pnl,
    timestamp: new Date().toISOString(),
    reason: win ? 'Strategy Signal' : 'Stop Loss'
  };

  io.emit("performanceUpdate", {
    pnl: perf.pnl,
    balance: perf.balance,
    trades: perf.trades,
    winRate,
    tradeHistory: [trade]
  });
  
  io.emit("tradeExecuted", {
    trade: trade,
    balance: perf.balance,
    performance: {
      totalTrades: perf.trades,
      winningTrades: perf.wins,
      losingTrades: perf.trades - perf.wins,
      winRate: winRate,
      totalPnL: perf.pnl,
      maxDrawdown: Math.abs(perf.pnl * 0.1),
      sharpeRatio: 1.2
    }
  });
  
  io.emit("log", `${new Date().toISOString()} Trade ${win ? "WIN" : "LOSS"} ${pnl} on ${trade.symbol}`);
}

io.on("connection", (socket) => {
  console.log("Client connected:", socket.id);
  socket.emit("log", "Connected to minimal trading engine");

  socket.on("startDemo", () => {
    if (demoInterval) return;
    console.log("Starting demo mode");
    io.emit("log", "Starting demo mode - simulating live trading");
    demoInterval = setInterval(() => {
      emitTicks();
      if (Math.random() < 0.35) fakeTrade();
    }, 1000);
  });

  socket.on("startLive", (cfg) => {
    console.log("Live mode requested:", cfg);
    io.emit("log", `Live mode requested with ${JSON.stringify(cfg)}`);
    // TODO: Connect to real data streams
  });

  socket.on("startTrading", ({ strategy, parameters }) => {
    console.log("Strategy trading started:", strategy, parameters);
    io.emit("log", `Started ${strategy} strategy with parameters: ${JSON.stringify(parameters)}`);
    io.emit("tradingStatus", {
      isRunning: true,
      strategy: strategy,
      balance: perf.balance,
      positions: [],
      trades: [],
      performance: {
        totalTrades: perf.trades,
        winningTrades: perf.wins,
        losingTrades: perf.trades - perf.wins,
        winRate: perf.trades ? Math.round((perf.wins / perf.trades) * 100) : 0,
        totalPnL: perf.pnl,
        maxDrawdown: Math.abs(perf.pnl * 0.1),
        sharpeRatio: 1.2
      }
    });
  });

  socket.on("backtest", ({ symbol, strategy }) => {
    console.log("Backtest requested:", symbol, strategy);
    // TODO: plug into your backtester; fake quick result for now
    const result = { symbol, strategy, trades: 120, winRate: 54, pnl: 320.5 };
    io.emit("log", `Backtest completed: ${JSON.stringify(result)}`);
    io.emit("performanceUpdate", {
      pnl: +(perf.pnl + result.pnl).toFixed(2),
      balance: +(10000 + perf.pnl + result.pnl).toFixed(2),
      trades: perf.trades + result.trades,
      winRate: Math.round((perf.wins + Math.round(result.trades * result.winRate / 100)) / (perf.trades + result.trades) * 100),
    });
  });

  socket.on("stopTrading", () => {
    console.log("Trading stopped");
    io.emit("log", "Trading stopped");
    io.emit("tradingStatus", {
      isRunning: false,
      strategy: null,
      balance: perf.balance,
      positions: [],
      trades: [],
      performance: {
        totalTrades: perf.trades,
        winningTrades: perf.wins,
        losingTrades: perf.trades - perf.wins,
        winRate: perf.trades ? Math.round((perf.wins / perf.trades) * 100) : 0,
        totalPnL: perf.pnl,
        maxDrawdown: Math.abs(perf.pnl * 0.1),
        sharpeRatio: 1.2
      }
    });
  });

  socket.on("stopAll", () => {
    if (demoInterval) {
      clearInterval(demoInterval);
      demoInterval = null;
    }
    console.log("All engines stopped");
    io.emit("log", "All trading engines stopped");
  });

  socket.on("getTradingStatus", () => {
    socket.emit("tradingStatus", {
      isRunning: demoInterval !== null,
      strategy: demoInterval ? "Demo Mode" : null,
      balance: perf.balance,
      positions: [],
      trades: [],
      performance: {
        totalTrades: perf.trades,
        winningTrades: perf.wins,
        losingTrades: perf.trades - perf.wins,
        winRate: perf.trades ? Math.round((perf.wins / perf.trades) * 100) : 0,
        totalPnL: perf.pnl,
        maxDrawdown: Math.abs(perf.pnl * 0.1),
        sharpeRatio: 1.2
      }
    });
  });

  socket.on("disconnect", () => {
    console.log("Client disconnected:", socket.id);
  });
});

server.listen(PORT, () => {
  console.log(`ðŸš€ Minimal trading server listening on port ${PORT}`);
  console.log(`ðŸ“¡ Socket.IO endpoint: http://localhost:${PORT}/socket.io`);
  console.log(`ðŸ”Œ Health check: http://localhost:${PORT}/api/health`);
});
